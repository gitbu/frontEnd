# number

## 浮点数精度问题

运算里只要有浮点数存在，就有可能**精度丢失**

```js
// 加法 =====================
// 0.1 + 0.2 = 0.30000000000000004
// 0.7 + 0.1 = 0.7999999999999999
// 0.2 + 0.4 = 0.6000000000000001
// 2.22 + 0.1 = 2.3200000000000003
 
// 减法 =====================
// 1.5 - 1.2 = 0.30000000000000004
// 0.3 - 0.2 = 0.09999999999999998
 
// 乘法 =====================
// 19.9 * 100 = 1989.9999999999998
// 19.9 * 10 * 10 = 1990
// 1306377.64 * 100 = 130637763.99999999
// 1306377.64 * 10 * 10 = 130637763.99999999
// 0.7 * 180 = 125.99999999999999
// 9.7 * 100 = 969.9999999999999
// 39.7 * 100 = 3970.0000000000005
 
// 除法 =====================
// 0.3 / 0.1 = 2.9999999999999996
// 0.69 / 10 = 0.06899999999999999

```

### 原因

js存储数据是64位双精度存储，用52位来存储有效数子

小数部分转化成二进制，有可能是无线循环的

但js存储小数部分的有效数字只能是52位，所以就会截断后再运算，所以就有可能丢失精度



### 解决方案

思路：先按两个数小数位最长的倍数把两个数变成整数， 运算完后， 再缩小

缺点：扩大后有也有可能会精度丢失，我这里目前还没有好的办法



## 四舍五入问题

在保留n位小数进行四舍五入的情况下，相信大家首选`toFixed`,但是大家知道吗，这个`toFixed`是有bug的

**例子**：

```js
(1.115).toFixed(2) // 1.11
```

那四舍五入应该用什么呢？

```js
// 方法一：Math.round
function round(number, precision) {
    return +(Math.round(+number + 'e' + precision) + `e-${precision}`)
}

// 方法二： 截取
function round(number, presision) {
  const [int, decimals] = String(number).split('.');
  let precisionDecimals = +decimals.slice(0, presision);
  
  if (decimals[presision] > 4) precisionDecimals++;
  
  return parseFloat(int + '.' + precisionDecimals)
}
```

